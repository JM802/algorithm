# 递归

## 一、前序、中序、后序遍历

1. 利用引用传递：此时相当于修改了共享的变量(global vision)，如果是迷宫问题需要回溯。

   ```cpp
    void traversal(TreeNode*cur,vector<int>&v)
       {
           if(!cur)
           {
               return;
           }
           v.push_back(cur->val);
           traversal(cur->left, v);
           traversal(cur->right, v);
       }
   ```
2. 利用值传递，每一层都是名字相同但没有任何关系的变量，需要存储返回值。

   ```cpp
    vector<int>preorderTraversal1(TreeNode*root)
       {
           if(!root)
           {
               return {};
           }

           vector<int> res = {};
           res.push_back(root->val);

           vector<int> left_res = preorderTraversal1(root->left);
           vector<int> right_res = preorderTraversal1(root->right);
           res.insert(res.end(), left_res.begin(), left_res.end());
           res.insert(res.end(), right_res.begin(), right_res.end());

           return res;
       }
   ```
3. 前序是先处理当前问题，再处理子问题；后序是先处理子问题，再处理当前问题（需要返回值）。比如求树的高度就是典型的后序问题
